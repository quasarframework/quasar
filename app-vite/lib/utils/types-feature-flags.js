import { join, dirname } from 'node:path'
import { writeFileSync, existsSync } from 'node:fs'

import { log } from './logger.js'

export async function regenerateTypesFeatureFlags (quasarConf) {
  const template = `/* eslint-disable */
// THIS FEATURE-FLAG FILE IS AUTOGENERATED,
//  REMOVAL OR CHANGES WILL CAUSE RELATED TYPES TO STOP WORKING
import "quasar/dist/types/feature-flag";

declare module "quasar/dist/types/feature-flag" {
  interface QuasarFeatureFlags {
    __FEATURE_NAME__: true;
  }
}
`

  // Flags must be available even in pure JS codebases,
  //    because boot and configure wrappers functions files will
  //    provide autocomplete based on them also to JS users
  // Flags files should be copied over, for every enabled mode,
  //    every time `quasar dev` and `quasar build` are run:
  //    this automatize the upgrade for existing codebases
  const { appPaths, mode } = quasarConf.ctx

  if (quasarConf.metaConf.hasStore === true) {
    const destFlagPath = appPaths.resolve.app(
      join(dirname(quasarConf.sourceFiles.store), 'store-flag.d.ts')
    )

    if (!existsSync(destFlagPath)) {
      writeFileSync(
        destFlagPath,
        template.replace('__FEATURE_NAME__', 'store')
      )
      log('"store" feature flag was missing and has been regenerated')
    }
  }

  for (const modeName of Object.keys(mode)) {
    if (modeName === 'spa' || mode[ modeName ] !== true) {
      continue
    }

    const destFlagPath = appPaths.resolve[ modeName ](`${ modeName }-flag.d.ts`)

    if (!existsSync(destFlagPath)) {
      writeFileSync(
        destFlagPath,
        template.replace('__FEATURE_NAME__', modeName)
      )
      log(`"${ modeName }" feature flag was missing and has been regenerated`)
    }
  }
}
