process.env.BABEL_ENV = 'production'

const path = require('path')
const fs = require('fs')
const rollup = require('rollup')
const uglify = require('uglify-es')
const buble = require('@rollup/plugin-buble')
const json = require('@rollup/plugin-json')
const nodeResolve = require('@rollup/plugin-node-resolve')
const buildConf = require('./build.conf')
const buildUtils = require('./build.utils')

const bubleConfig = {
  objectAssign: 'Object.assign'
}

const defaultRollupPlugins = [
  nodeResolve({
    extensions: ['.js'],
    preferBuiltins: false
  }),
  json(),
  buble(bubleConfig)
]

const builds = [
  {
    rollup: {
      input: {
        input: resolve(`src/index.esm.js`)
      },
      output: {
        file: resolve(`dist/quasar.esm.js`),
        format: 'es'
      }
    },
    build: { minified: true, minExt: false }
  },
  {
    rollup: {
      input: {
        input: resolve(`src/index.common.js`)
      },
      output: {
        file: resolve(`dist/quasar.common.js`),
        format: 'cjs'
      }
    },
    build: {
      minified: true,
      minExt: false
    }
  },
  {
    rollup: {
      input: {
        input: resolve('src/ie-compat/ie.js')
      },
      output: {
        file: resolve('dist/quasar.ie.polyfills.js'),
        format: 'es'
      }
    },
    build: { minified: true, minExt: false }
  },
  {
    rollup: {
      input: {
        input: resolve('src/ie-compat/ie.js')
      },
      output: {
        file: resolve('dist/quasar.ie.polyfills.umd.js'),
        format: 'umd'
      }
    },
    build: { minified: true }
  },
  {
    rollup: {
      input: {
        input: resolve(`src/index.umd.js`)
      },
      output: {
        file: resolve(`dist/quasar.umd.js`),
        format: 'umd'
      }
    },
    build: {
      unminified: true,
      minified: true
    }
  }
]

const svgIconSetBanner = setName => `
/*
 * Do not edit this file. It is automatically generated
 * from its webfont counterpart (same filename without "svg-" prefix).
 * Edit that file instead (${setName}.js).
 */
`

function run () {
  addAssets(builds, 'lang', 'lang')
  addAssets(builds, 'icon-set', 'iconSet')

  build(builds)

  require('./build.api').generate()
    .then(async (data) => {
      await require('./build.lang-index').generate()
      addSvgIconSets()
      require('./build.transforms').generate()
      require('./build.vetur').generate(data)
      require('./build.types').generate(data)
      require('./build.web-types').generate(data)
    })
}

run()

/**
 * Helpers
 */

function resolve (_path) {
  return path.resolve(__dirname, '..', _path)
}

function addSvgIconSets () {
  // generic conversion
  const convert = str => str.replace(/(-\w)/g, m => m[1].toUpperCase())

  const iconTypes = [
    {
      name: 'material-icons',
      regex: /_/,
      convert: str => ('mat_' + str).replace(/(_\w)/g, m => m[1].toUpperCase())
    },
    {
      name: 'mdi-v4',
      regex: /^mdi-/,
      convert
    },
    {
      name: 'fontawesome-v5',
      regex: /^fa[brs] fa-/,
      convert: str => str.replace(' fa-', '-').replace(/(-\w)/g, m => m[1].toUpperCase())
    },
    {
      name: 'eva-icons',
      regex: /^eva-/,
      convert
    },
    {
      name: 'themify',
      regex: /^ti-/,
      convert
    }
  ]

  function convertWebfont (name) {
    const type = iconTypes.find(type => type.regex.test(name)) || iconTypes[0]

    return {
      importName: type.name,
      variableName: type.convert(name)
    }
  }

  function toObject (arr) {
    const obj = {}
    arr.forEach(item => {
      obj[item] = []
    })
    return obj
  }

  const iconNames = iconTypes.map(type => type.name)

  iconTypes.forEach(type => {
    const original = fs.readFileSync(resolve(`icon-set/${type.name}.js`), 'utf-8')

    const importList = toObject(iconNames)

    const contentString = original
      .replace(/name: '(.+)'/, `name: ""`)
      .replace(/'(.+)'/g, m => {
        const { importName, variableName } = convertWebfont(m.substring(1, m.length - 1))
        if (!importList[importName].includes(variableName)) {
          importList[importName].push(variableName)
        }
        return variableName
      })
      .replace(/name: ""/, `name: 'svg-${type.name}'`)

    const importString = Object.keys(importList)
      .filter(listName => importList[listName].length > 0)
      .map(listName => `import {\n  ` + importList[listName].join(',\n  ') + `\n} from '@quasar/extras/${listName}'`)
      .join('\n\n')

    const content = svgIconSetBanner(type.name) + '\n' + importString + '\n\n' + contentString

    buildUtils.writeFile(resolve(`icon-set/svg-${type.name}.js`), content, 'utf-8')
  })
}

function addAssets (builds, type, injectName) {
  const
    files = fs.readdirSync(resolve(type)),
    plugins = [ buble(bubleConfig) ]

  files
    .filter(file => file.endsWith('.js') && file.indexOf('svg-') === -1)
    .forEach(file => {
      const name = file.substr(0, file.length - 3).replace(/-([a-z])/g, g => g[1].toUpperCase())
      builds.push({
        rollup: {
          input: {
            input: resolve(`${type}/${file}`),
            plugins
          },
          output: {
            file: addExtension(resolve(`dist/${type}/${file}`), 'umd'),
            format: 'umd',
            name: `Quasar.${injectName}.${name}`
          }
        },
        build: {
          minified: true
        }
      })
    })
}

function build (builds) {
  return Promise
    .all(builds.map(genConfig).map(buildEntry))
    .catch(buildUtils.logError)
}

function genConfig (opts) {
  if (opts.rollup.input.plugins === void 0) {
    opts.rollup.input.plugins = defaultRollupPlugins
  }

  opts.rollup.input.external = opts.rollup.input.external || []
  opts.rollup.input.external.push('vue')

  opts.rollup.output.banner = buildConf.banner
  opts.rollup.output.name = opts.rollup.output.name || 'Quasar'

  opts.rollup.output.globals = opts.rollup.output.globals || {}
  opts.rollup.output.globals.vue = 'Vue'

  return opts
}

function addExtension (filename, ext = 'min') {
  const insertionPoint = filename.lastIndexOf('.')
  return `${filename.slice(0, insertionPoint)}.${ext}${filename.slice(insertionPoint)}`
}

function injectVueRequirement (code) {
  const index = code.indexOf(`Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue`)

  if (index === -1) {
    return code
  }

  const checkMe = ` if (Vue === void 0) {
    console.error('[ Quasar ] Vue is required to run. Please add a script tag for it before loading Quasar.')
    return
  }
  `

  return code.substring(0, index - 1) +
    checkMe +
    code.substring(index)
}

function buildEntry (config) {
  return rollup
    .rollup(config.rollup.input)
    .then(bundle => bundle.generate(config.rollup.output))
    .then(({ output }) => {
      const code = config.rollup.output.format === 'umd'
        ? injectVueRequirement(output[0].code)
        : output[0].code

      return config.build.unminified
        ? buildUtils.writeFile(config.rollup.output.file, code)
        : code
    })
    .then(code => {
      if (!config.build.minified) {
        return code
      }

      const minified = uglify.minify(code, {
        compress: {
          pure_funcs: ['makeMap']
        }
      })

      if (minified.error) {
        return Promise.reject(minified.error)
      }

      return buildUtils.writeFile(
        config.build.minExt !== false
          ? addExtension(config.rollup.output.file)
          : config.rollup.output.file,
        buildConf.banner + minified.code,
        true
      )
    })
    .catch(err => {
      console.error(err)
      process.exit(1)
    })
}
